Class BDoomMonster : Actor abstract
{
TranslatedBurningBody burncorpse;
double smokeheight;
property smokeheight : smokeheight;
int monsterclip; //used by monsters with guns when bdoom_weapons == 2
property monsterclip : monsterclip;

bool burning; //is showing burning or smoking animation
int burntimer;
int firetype; //0 = only smoke; 1 = regular yellow; 2 = baron green

bool highfall;
/*void BD_CheckFall() {
	if (pos.z >= floorz+128)
		highfall = true;
	}
void BD_Drop() {
	if (highfall)
		A_PlaySound("body/fall");
	}*/
/*bool allowfiredeath;
bool allowsmokedeath;
property allowfiredeath : allowfiredeath;
property allowsmokedeath : allowsmokedeath;*/

Default {
	Monster;
	BDoomMonster.monsterclip 10;
	BDoomMonster.smokeheight 0;
	/*BDoomMonster.allowsmokedeath true;
	BDoomMonster.allowfiredeath true;*/
	attacksound "none";
	bloodtype "BD_Blood", "BD_Blood", "BloodSpurt";
	//+DOHARMSPECIES
	}
	
void BD_Bleed() {
	if (!burning && bdoom_blood)
		A_SpawnItemEx("Blood",frandom(-5.0,5.0),frandom(-5.0,5.0),frandom(16,default.height),frandom(-2,2),frandom(-2,2),frandom(1,3),SXF_SETTARGET);
	}

void BD_BulletAttack(double horz_spread, double vert_spread, int numbullets, int damageperbullet, string OldSound, string NewSound, string Casing, double CasingX = 0, double CasingY = 0, double CasingZ = 0, double TracerHeight = 32, double Tracerofs_xy = 0, class<Actor> puff = "EnBulletPuff")
	{		
	if (bdoom_debris)
		A_SpawnItemEx(Casing,CasingX,CasingY,CasingZ,		frandom(2,4),0,frandom(2,4),	random(-85,-95),SXF_SETTARGET);
	If(bdoom_weapons)
		A_PlaySound(newsound);
	else			
		A_PlaySound(oldsound);
	if (bdoom_tracers)
		A_CustomBulletAttack(horz_spread, vert_spread, numbullets, damageperbullet, puff, 0, CBAF_NORANDOM,AAPTR_TARGET,"BulletTracer",TracerHeight,Tracerofs_xy);
	else
		A_CustomBulletAttack(horz_spread, vert_spread, numbullets, damageperbullet, puff, 0, CBAF_NORANDOM);
	}

state BD_Refire(int ChanceToEnd = 0, statelabel endstate = "See") 
	{ 
	if (bdoom_weapons < 2)
		return ResolveState("See");
	else if (monsterclip == 0)
		return ResolveState("Reload");
	else if (ChanceToEnd > random(0,256))
		return ResolveState(endstate);
	else
		return A_MonsterRefire(40,endstate);
	return ResolveState(null);
	}
	
override void Tick() {
	super.Tick();
	if (level.isFrozen() || !bdoom_flames)
		return;
	if (burning && !InStateSequence(curstate,ResolveState("See")))
		{
		burntimer++;
		if (burntimer < 256)
			A_SpawnItemEx("BlackSmoke",frandom(-16,16),frandom(-16,16),smokeheight + frandom(8,16),0,0,frandom(0.4,0.9),0,0,80);
		else {
			A_SpawnItemEx("BlackSmoke",frandom(-16,16),frandom(-16,16),smokeheight + frandom(8,16),0,0,frandom(0.4,0.9),0,0,burntimer*0.8);
			}
		}
		
	else {
		burning = false;
		burntimer = 0;
		if (burncorpse)
			burncorpse.destroy();
		return;
		}
	}

void BD_Gibs()
    {
	if (bdoom_gibs == 0)
		return;

	A_PlaySound("gibs/gibbed",volume:0.65);
	for (int i = 18; i > 0; i--)
		A_SpawnItemEx("BFountainSpray",frandom(-5.0,5.0),frandom(-5.0,5.0),random(8,28),vel.x*frandom(0.05,0.15),vel.y*frandom(0.05,0.15),frandom(4.5,6.5),0,SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION,36);
	for (int i = 6; i > 0; i--)
		A_SpawnItemEx("BasicMeatPiece",random(-4,4),random(-4,4),random(10,48),		vel.x*frandom(0.35,1.2),vel.y*frandom(0.35,1.2),random(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 64);

	A_SpawnItemEx("Gib_Intestine",	frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 92);
	A_SpawnItemEx("Gib_Intestine",	frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 170);
	A_SpawnItemEx("Gib_Lung",		frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 144);
	A_SpawnItemEx("Gib_Lung",		frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 144);
	A_SpawnItemEx("Gib_liver",		frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 128);
	A_SpawnItemEx("Gib_kidneys",	frandom(-4,4),frandom(-4,4),frandom(8,28),vel.x*frandom(0.3,0.8),vel.y*frandom(0.3,0.8),frandom(3,5),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 128);
	
	A_SpawnItemEx("Gib_Hand",		frandom(6,4),frandom(-4,4),frandom(35,40),	vel.x*frandom(0.35,1.2), vel.y*frandom(0.35,1.2),frandom(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 32);
	A_SpawnItemEx("Gib_Hand",		frandom(6,4),frandom(-4,4),frandom(35,40),	vel.x*frandom(0.35,1.2), vel.y*frandom(0.35,1.2),frandom(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 32);
	A_SpawnItemEx("Gib_Leg",		frandom(6,4),frandom(-4,4),frandom(10,12),	vel.x*frandom(0.35,1.2), vel.y*frandom(0.35,1.2),frandom(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 32);
	A_SpawnItemEx("Gib_Leg",		frandom(6,4),frandom(-4,4),frandom(10,12),	vel.x*frandom(0.35,1.2), vel.y*frandom(0.35,1.2),frandom(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 32);
	A_SpawnItemEx("Gib_head",		frandom(-2,2),frandom(-2,2),frandom(42,48),vel.x*frandom(0.35,1.2), vel.y*frandom(0.35,1.2),frandom(5,10),	0,	SXF_ABSOLUTEVELOCITY | SXF_SETTARGET | SXF_TRANSFERTRANSLATION, 32);
	
	actor torso1 = Spawn("Gib_Torso1",(pos.x+frandom(-8,8),pos.y+frandom(-8,8),pos.z+frandom(18,28)));
	torso1.vel.x = vel.x*frandom(0.7,0.95);
	torso1.vel.y = vel.y*frandom(0.7,0.95);
	torso1.vel.z = vel.z*frandom(0.7,0.95);
	torso1.target = self;
	torso1.scale.x = randompick(-1,1);
	torso1.translation = translation;
	actor torso2 = Spawn("Gib_Torso2",(pos.x,pos.y+frandom(-8,8),pos.z+frandom(12,24)));
	torso2.vel.x = vel.x*frandom(0.7,0.95);
	torso2.vel.y = vel.y*frandom(0.7,0.95);
	torso2.vel.z = vel.z*frandom(0.7,0.95);
	torso2.target = self;
	torso2.translation = translation;
	if (torso1.scale.x == -1) //horizontal scale is randomized but synced between pieces of the same torso, so it doesn't look like 2 left halves or 2 right halves
		torso2.scale.x = -1;
    }
	
states
	{
	Crush:
		CRS1 A -1;
		stop;
	Deathbleed: //for spawning animated blood pool and flies
		#### # random(35,55) {
			if (bBOSSDEATH)
				A_BossDeath();				
			if (burning)
				return ResolveState("DeathEnd");
			return ResolveState(null);
			}
		#### # 1 {
			if (vel.length() ~== 0) {
				if (bdoom_blood)
					A_SpawnItemEx("AniBloodPool",0,0,0,0,0,0,0,SXF_SETTARGET|SXF_USEBLOODCOLOR);
				A_SpawnItemEx("CorpseFlySpawner",0,0,0,0,0,0,0,SXF_SETMASTER);
				return ResolveState("DeathEnd");
				}
			return ResolveState(null);
			}
		wait;
	DeathEnd:
		#### # -1;
		stop;
	Raise:
		#### # 2 {
			//raised = true;
			if (self.frame > 0)
				self.frame-=1;
			else
				{
				bFORCEXYBILLBOARD = default.bFORCEXYBILLBOARD;
				translation = default.translation;
				scale.x = default.scale.x;
				scale.y = default.scale.y;
				burning = false;
				burntimer = 0;
				return ResolveState("See");
				}
			return ResolveState(null);
			}
		loop;
	Death.SSG:
		#### # 0 {
			//console.printf("%d",health);
			if (random(1,3) == 1 && FindState("XDeath"))
				return ResolveState("XDeath");
			return ResolveState("Death");
			}
		stop;
	Death.Telefrag:
	Death.Massacre:
		TNT1 A 0 {
			if (FindState("XDeath.Vanilla"))
				return ResolveState("XDeath.Vanilla");
			else if (FindState("XDeath"))
				return ResolveState("XDeath");
			return ResolveState("Death");
			}
		POSX AB 2;
		POSX C 2 A_XScream();
		POSX D 2 A_NoBlocking();
		POSX EFGHIJKLMN 2;
		POSX O -1;
		stop;
	Death.Fire:
		TNT1 A 0 {
			burncorpse = TranslatedBurningBody(Spawn("TranslatedBurningBody",pos));
			burncorpse.master = self;
			burncorpse.A_SetTranslation("Firedeath");
			if (bdoom_flames) {
				let bflame = BurningBodyFlame(Spawn("BurningBodyFlame",pos));
				bflame.master = self;
				}
			return ResolveState("DoFireDeath");
			}
		stop;
	Death.GreenFire:
		TNT1 A 0 {
			burncorpse = TranslatedBurningBody(Spawn("TranslatedBurningBody",pos));
			burncorpse.master = self;
			burncorpse.A_SetTranslation("GreenFiredeath");
			if (bdoom_flames) {
				let bflame = BurningBodyFlame(Spawn("BurningBodyFlame",pos));
				bflame.master = self;
				bflame.SetStateLabel("SpawnGreen");
				}
			return ResolveState("DoFireDeath");
			}
		stop;
	Death.PlasmaDamage:
		TNT1 A 0 {
			burncorpse = TranslatedBurningBody(Spawn("TranslatedBurningBody",pos));
			burncorpse.master = self;
			burncorpse.fadestart = 0;
			burncorpse.fadespeed = 0.03;
			return ResolveState("DoFireDeath");
			}
		stop;
	DoFireDeath:
		TNT1 A 0 {
			burning = true;
			burntimer = 0;
			A_SetTranslation("Scorched");
			return ResolveState("Death");
			}
		stop;
	Death.BFGSplash:
		TNT1 A 0 {
			if (bloodcolor.B > 4*(bloodcolor.R  + bloodcolor.G))
				A_SetTranslation("BlueBloodyScorched");
			else if (bloodcolor.G > 4*(bloodcolor.R  + bloodcolor.B))
				A_SetTranslation("GreenBloodyScorched");
			else
				A_SetTranslation("BloodyScorched");
			if (FindState("Xdeath"))
				return ResolveState("XDeath");
			return ResolveState("Death");
			}
		stop;
	XDeath.Particles:
		TNT1 A 1 {
			//A_XScream();
			A_NoBlocking();
			BD_Gibs();
			}
		TNT1 ABCDEFGHIJKLMN 2;
		goto DeathEnd;
	}
}

/*This is spawned by a burning monster and receives a "fire" translation from it,
while the monster receives "scorched" translation. As this fades out, it creates
an effect of smooth transition from burning to scorched.
*/
Class TranslatedBurningBody : Actor
{
double fadespeed; //how quickly it fades
int fadestart;	//when it starts to fade
int fadetime;	//timer
property fadespeed : fadespeed;
property fadestart : fadestart;
Default {
	TranslatedBurningBody.fadespeed 0.008;
	TranslatedBurningBody.fadestart 100;
	+NOINTERACTION
	+NOBLOCKMAP
	+MOVEWITHSECTOR
	+RELATIVETOFLOOR
	renderstyle "Translucent";
	alpha 1.0;
	}
override void Tick() {
	super.Tick();
	if (level.isFrozen())
		return;
	if (waterlevel > 1) {
		destroy();
		return;
		}
	if (fadetime < fadestart)
		fadetime++;
	else
		A_FadeOut(fadespeed);
	}
states
	{
	Spawn:
		TNT1 A 1 NoDelay {
			if (!master) {
				destroy();
				return;
				}
			sprite = master.sprite;
			frame = master.frame;
			scale = master.scale;
			SetOrigin(master.pos,true);
			}
		loop;
	}
}

Class BurningBodyFlame : Actor
{
int burntimer;
Default {
	+NOINTERACTION
	+NOBLOCKMAP
	+MOVEWITHSECTOR
	+RELATIVETOFLOOR
	renderstyle "Add";
	alpha 0.8;
	xscale 1.0;
	yscale 0.65;
	}
override void PostBeginPlay() {
	super.PostBeginPlay();
	if (!master){
		self.destroy();
		return;
		}
	scale.x = master.radius*0.06; //radius of 20 = xscale 1.0
	scale.y = scale.x*0.5;
	}
override void Tick () {
	super.Tick();
	if (level.isFrozen())
		return;
	if (waterlevel > 1) {
		destroy();
		return;
		}
	if (!master || !bdoom_flames) {
		self.destroy();
		return;
		}
	SetOrigin(master.pos,true);
	burntimer++;
	if (burntimer > 100) {
		scale.y*=0.995;
		A_FadeOut(0.005);
		}
	}
states
	{
	Spawn:
		BBR1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 bright;
		BBR2 ABCDEF 1 bright;
		loop;
	SpawnGreen:
		BGR1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 bright;
		BGR2 ABCDEF 1 bright;
		loop;
	}
}


Class BD_ZombieBullet : BD_PistolBullet
{
override void PostBeginPlay()
	{
	super.PostBeginPlay();
	BulletDamage = 3 * frandom(1,5);
	}
}

Class BD_ZombiePellet : BD_ShotgunPellet
{
override void PostBeginPlay()
	{
	super.PostBeginPlay();
	BulletDamage = 2 * frandom(3,4);
	}
}

Class BD_SpiderBullet : BD_PistolBullet
{
override void PostBeginPlay()
	{
	super.PostBeginPlay();
	BulletDamage = 2 * frandom(2,4);
	}
}