Class BD_BloodBase : BD_BaseDebris abstract {
	static const name bsprite[] = { "YBL7","YBL8","YBL9" };
	Default {
		BD_BaseDebris.sfxtype "blood";
		+PUFFGETSOWNER
		-NOGRAVITY
		+DONTSPLASH
		gravity 0.7;
		renderstyle "Translucent";
		seesound "none";
		Deathsound "none";
		decal "none";
		height 1;
	}
	/*override void Tick() {
		super.Tick();
		if (target)
			console.printf("%s - %s",self.GetClassName(),target.GetClassName());
	}*/
	states	{
		LoadSprites:
			2PLT ABCDEFGHIJKLMNOPQ 0;
			YBL7 ABCDEFGHIJKLMNOPQRS 0;
			YBL8 ABCDEFGHIJKLMNOPQRS 0;
			YBL9 ABCDEFGHIJKLMNOPQRS 0;
			stop;
		Fade:
			#### # 1 A_FadeOut(0.02);
			loop;
	}
}

Class BD_BloodyPrintControl : Inventory {
	FXAmountControl event;
	private int bloodtrack; //how much blood was "collected by our boots"
	private bool side;
	private bool drip;
	property drip : drip;
	private array <BD_BloodBase> bootsblood;
	Default {
		BD_BloodyPrintControl.drip false;
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		inventory.maxamount 1;
	}
	static const name LiquidFloors[] = { 
		"BLOOD1", "BLOOD2", "BLOOD3", "SLIME01", "SLIME02", "SLIME03", "SLIME04", "SLIME05", "SLIME06", "SLIME07", "SLIME08", "SLIME09", "SLIME10", "SLIME11", "SLIME12"
	};
	bool CheckWater(actor checker = null) {
		if (!checker)
			checker = self;
		if (checker.waterlevel > 0)
			return true;
		if (checker.GetFloorTerrain().isLiquid == true)
			return true;
		string flr = TexMan.GetName(checker.floorpic);
		if (flr.IndexOf("WATER") >= 0 || flr.IndexOf("LAVA") >= 0 || flr.IndexOf("NUKAGE") >= 0)
			return true;
		for (int i = 0; i < LiquidFloors.Size(); i++) {
			if (flr == LiquidFloors[i])
				return true;
		}
		return false;
	}
	override void DoEffect() {
		super.DoEffect();		
		if (!owner || !bdoom_blood || !owner.player || level.isFrozen())
			return;
		//debug
		//Console.Printf("blood on boots: %d | vel: %d",bootsblood.Size(),owner.vel.length());
		event = FXAmountControl(EventHandler.find("FXAmountControl"));
		if (!event)
			return;
		//blood isn't collected on boots and prints aren't spawned if we're not on the floor or are barely moving
		if (!(owner.pos.z ~== owner.floorz))
			return;
		if (CheckWater(owner)) {
			bootsblood.Clear();
			return;
		}
		double pspeed = owner.vel.length();
		if (drip && (level.time % 6 == 0))
			bootsblood.delete(0);
		if (bootsblood.Size() < 48 && pspeed > 4) {
			for (int i = 0; i < event.bloodlist.Size(); i++) {
				if (bootsblood.Size() >= 48)
					break;
				let pool = BD_BloodBase(event.bloodlist[i]);
				if (!pool || !pool.bNOINTERACTION || /*!(pool.pos.z ~== pool.floorz) ||*/ bootsblood.Find (pool) != bootsBlood.Size ())
					continue;
				if (pool is "BD_Blood" || pool is "AniBloodPool") {
					/*let diff = owner.Vec3To (pool);
					double combinedRadius = owner.radius + pool.radius;
					if ((diff.XY dot diff.XY) < (combinedRadius * combinedRadius))*/
					let diff = owner.Distance2D(pool);
					if (pool.floorz == owner.floorz && diff <= owner.radius)
						bootsblood.Push(pool);
				}
			}
		}
		if (bootsblood.Size() > 12 && (level.time % 6 == 0) && pspeed >= 2) {
			drip = true;
			let print = BD_BloodyFootPrint(Spawn("BD_BloodyFootPrint",(owner.pos.x,owner.pos.y,owner.floorz)));
			if (print) {
				print.side = side;
				print.angle = owner.angle;
				side = !side;
			}
		}
		else if (bootsblood.Size() == 0)
			drip = false;
	}
}

Class BD_BloodyFootPrint : BD_BloodBase {
	bool side;
	Default {
		-MISSILE
		+NOINTERACTION
		+MOVEWITHSECTOR
		+RELATIVETOFLOOR
		renderstyle 'Translucent';
		alpha 1.0;
		radius 4;
		scale 1;
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		if (CheckWater() || CheckLandingSize(8)) {
			destroy();
			return;
		}
		SetZ(floorz+frandom(0,0.01));
		int hoff = -1;
		if (side)
			hoff = 1;
		Warp(self,0,4*hoff);
	}
	override void Tick() {
		super.Tick();
		if (!isFrozen())
			A_FadeOut(0.001);
	}
	states {
		Spawn:
			0000 A -1 NoDelay {
				if (side)
					frame = 1;				
			}
			stop;
	}
}

Class BD_Blood : BD_BloodBase {
	double restscale;
	Default {
		scale 0.35;
		gravity 0.5;
		renderstyle "Translucent";
		alpha 0.8;
		height 1;
		radius 1;
		deathsound "none";
	}
	/* 
	I'm only doing the crap below because we don't have direct control over decals, so while I can translate the blood particles created by enemies, 
	I can't translate the decals created by said blood particles (only the decals automatically created behind monsters are translated). Hence the ugly math.
	I could just use BloodTranslation directly for all cases, but that makes the sprite have only one color which diminishes the details 
	(if blood is red, for example, it doesn't mean that the whole image is red, it'll have black and white parts as well). Hence I use manual translation 
	for blue and green and then BloodTranslation for any other color (if it's used).
	 */
	override void PostBeginPlay() {
		if (!bdoom_blood || !target){
			destroy();
			return;
		}
		if (target && (target is "BDoomMonster")) {
			let trg = BDoomMonster(target);
			if (trg) {
				if (trg.burning){
					destroy();
					return;
				}
				trg.meatlist.push(self);
			}
		}
		SetBloodTranslation();
		restscale = frandom(0.1,0.18);
		Super.PostBeginPlay();
	}

	virtual void BD_BloodDecal() {
		if (bcolor == 'blue')
			A_SprayDecal("BloodSplatBlue",32);
		else if (bcolor == 'green')
			A_SprayDecal("BloodSplatGreen",32);
		else if (bcolor == 'red')
			A_SprayDecal("BloodSplatRed",32);
		//no way to transfer shade to decals, so blood of colors other than red/blue/green won't produce decals (they'll still be produced by monsters directly, of course)
	}
	states {
		spawn:
			TNT1 AAA 0; //override hardcoded frame-skipping behavior for Blood
			TNT1 A 0 {
				A_FaceTarget(0,270,180,0);
				A_SetScale(scale.x*randompick(-1,1)*frandom(0.7,1.2),scale.y*randompick(-1,1)*frandom(0.7,1.2));
				roll = random(0,359);
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
				return resolvestate("BloodDo");
			}
		BloodDo:
			#### ABCDEFGHIJKLMNOPQRS 1 {
				if (waterlevel > 0)
					return ResolveState("Water");
				return ResolveState(null);
			}
			stop;
		Death:
			TNT1 A 0 { 
				A_Stop();
				BD_BloodDecal();
				A_Scream();
				//Spawn ceiling blood if it reaches the ceiling. I use ceiling-10 so that it happens more often; blood doesn't ACTUALLY often hit the ceiling
				if (pos.z >= ceilingz-10){
					let a = BD_CeilingPool(Spawn("BD_CeilingPool",(pos.x,pos.y,ceilingz)));
					if (a) {
						a.translation = translation;
						a.A_SetRenderStyle(alpha,GetRenderStyle());
						a.scale = scale;
						if (target && (target is "BDoomMonster"))	{
							a.target = target;
							let m = BDoomMonster(target);
							if (m) m.meatlist.Push(a);
						}
					}
					destroy();
					return ResolveState(null);
				}	
				//if the blood hits wall, or sky, or ends up underwater:
				if (floorpic == skyflatnum || pos.z > floorz || waterlevel > 1) { 
					destroy();
					return ResolveState(null);
				}
				A_SetScale(restscale);
				angle = random(0,359);
				if (CheckLandingSize(24))
					scale*=0.5;
				if	(CheckLandingSize(18))
					scale*=0.5;
				if	(CheckLandingSize(12))
					scale*=0.5;
				if	(CheckLandingSize(6)) {
					destroy();
					return ResolveState(null);
				}
//				A_SetSize(16*scale.x,5);				
				bNOINTERACTION = true;
				A_ChangeLinkFlags(blockmap:true);
				bMOVEWITHSECTOR = true;
				bRELATIVETOFLOOR = true;
				A_SetRenderStyle(1,STYLE_Normal);
				return ResolveState(null);
			}
			MODL A 0 { 
				frame = random(0,16);
				if (CheckWater())
					return ResolveState("Water");
				return ResolveState(null);
			}

			#### # -1;
			stop;
		Raise:
			TNT1 A 0 {
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
				roll = random(0,359);
				FlyBack();
			}
			#### SRQPONMLKJIHGFEDCBA 1 bright {
				A_FadeOut(0.03);
				if (target &&  Distance3D(target) < 32) {
					destroy();
					return ResolveState(null);
				}
				return ResolveState(null);
			}
			stop;
		FadeOut:
			#### # 0 A_SetRenderstyle(alpha,Style_Translucent);
			#### # 1 A_FadeOut(0.1);
			wait;
		Water:
			#### # 0 A_SetRenderStyle(alpha,STYLE_Translucent);
			#### # 1 {
				A_FadeOut(0.04);
				scale*=1.03;
			}
			wait;
	}
}

//resting version of blood drop without any animation
Class BD_BloodPool : BD_Blood {
	Default {
		-MISSILE
		+NOINTERACTION
		+FLATSPRITE
		+MOVEWITHSECTOR
		+RELATIVETOFLOOR
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		if (floorpic == skyflatnum || waterlevel > 0 || CheckWater()){
			destroy();
			return;
		}
		angle = random(0,359);
		if (CheckLandingSize(24))
			scale*=0.5;
		if	(CheckLandingSize(18))
			scale*=0.5;
		if	(CheckLandingSize(12))
			scale*=0.5;
		if	(CheckLandingSize(6)){
			destroy();
			return;
		}
		SetOrigin((pos.x,pos.y,floorz+frandom(0,0.01)),false);
	}
	states {
		spawn:
			MODL A 0 NoDelay { 
				frame = random(0,16); 
			}
			#### # -1;
			stop;
	}
}


Class BD_CeilingPool : BD_BloodBase {
	Default {
		-MISSILE
		+NOGRAVITY
		+FLATSPRITE
		+NOINTERACTION
		-RELATIVETOFLOOR
		-MOVEWITHSECTOR
		height 1;
		scale 0.35;
		renderstyle "Translucent";
		alpha 0.8;
	}
	Override Void PostBeginPlay() {
		super.PostBeginPlay();
		if (ceilingpic == skyflatnum) {
			destroy();
			return;
		}
		if (CheckLandingSize(24,true))
			scale*=0.5;
		if (CheckLandingSize(18,true))
			scale*=0.5;
		if (CheckLandingSize(12,true))
			scale*=0.5;
		if (CheckLandingSize(6,true)){
			destroy();
			return;
		}
	}
	states {
		Spawn:
			2PLT A 0 NoDelay {
				frame = random(0,16);
			}
			#### # 5 {
				SetOrigin((pos.x,pos.y,ceilingz-1),true);
				A_SpawnitemEx("BD_CeilingBloodDrop",frandom(-2.0,2.0),frandom(-2.0,2.0),-1.,0,0,0,0,SXF_TRANSFERTRANSLATION|SXF_TRANSFERSTENCILCOL|SXF_TRANSFERRENDERSTYLE|SXF_NOPOINTERS,250);
				A_FadeTo(0.1,0.001,1);
				return ResolveState(null);
			}
			wait;
		Raise:
			#### # 1 { return ResolveState("Fade"); }
			stop;
	}
}

Class BD_CeilingBloodDrop : BD_BloodBase {
	Default {
		+FORCEYBILLBOARD
		+NOINTERACTION
		-FLOORCLIP
		scale 0.1;
		alpha 0.75;
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		scale*= frandom(0.8,1.1);
		scale.x*=randompick(-1,1);	
	}
	states {
		spawn:
			BLOD UVWWXXYYY 2;
			TNT1 A 0 { vel.z = -3.4; }
			BLOD ZZZZZZZZZZZZZZZZZZZZZZZZZ 1 {
				if (waterlevel > 0) {
					destroy();
					return ResolveState(null);
				}
				if (pos.z <= floorz)
					return ResolveState("Death");
				return ResolveState(null);
			}
			stop;
		Death:
			TNT1 A 0 {
				vel.z = 0.0;
				SetOrigin((pos.x,pos.y,floorz),0);
				scale.x = frandom(0.22,0.25)*randompick(-1,1);
			}
			BLOD GHIJK 3;
			stop;
	}
}


Class AniBloodPool : BD_BloodBase {
	bool instant; //if true, the blood pool will instantly go through all the phases and reach the required size — for decorative purposes such as Heart Column, where animation is unneeded, but checking for overhang may still important
	double psize;
	private int ver;
	Default {
		+NOINTERACTION
		+RELATIVETOFLOOR
		+MOVEWITHSECTOR
		-MISSILE
		height 1;
		radius 16;
		renderstyle 'Normal';
		scale 0.2;
	}
	override void PostBeginPlay() {
		Super.PostBeginPlay();
		if (waterlevel > 0) {
			destroy();
			return;
		}
		
		double pscale = scale.x*frandom(1.1,1.8);
		psize = pscale*22;
		if (CheckLandingSize (psize) || waterlevel > 0) {
			destroy();
			return;
		}
		angle = random(0,359);
		SetBloodTranslation(changetranslation:false);
		SetZ(floorz+frandom(0,0.01));
	}	
	override void Tick () {
		super.Tick();
		if (isFrozen())
			return;
		if (CheckWater()) {
			A_SetRenderstyle(alpha,STYLE_Translucent);
			A_FadeOut(0.01);
		}
	}
	states	{
		Spawn:
			TNT1 A 0 NoDelay {
				ver = randompick(0,1);
				if (ver == 0) {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G000");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B000");
					else
						sprite = GetSpriteIndex("R000");
				}
				else {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G010");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B010");
					else
						sprite = GetSpriteIndex("R010");
				}
			}
			#### ABCDEFGHI 2 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=2.0;
				return ResolveState(null);
			}
			#### JKLMNOPQRSTU 2 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.2;
				return ResolveState(null);
			}
			#### VWXYZ 3 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.0;
				return ResolveState(null);
			}
			//running out of alphabet letters
			TNT1 A 0 {
				if (ver == 0) {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G001");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B001");
					else
						sprite = GetSpriteIndex("R001");
				}
				else {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G011");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B011");
					else
						sprite = GetSpriteIndex("R011");
				}
			}
			#### ABCD 3 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.0;
				return ResolveState(null);
			}
			goto rest;
		Rest:
			#### # -1;
			stop;
		Raise:
			#### # 0 {
				A_SetRenderstyle(alpha,STYLE_Translucent);
				//console.printf("fade blood pool");
			}
			#### # 1 {
				scale*=0.92;
				A_FadeOut(0.03);
			}
			wait;
		LoadSprites:
			R000 ABCDEFGHIJKLMNOPQRSTUVWXYZ 0;
			R001 ABCD 0;
			R010 ABCDEFGHIJKLMNOPQRSTUVWXYZ 0;
			R011 ABCD 0;
			G000 ABCDEFGHIJKLMNOPQGSTUVWXYZ 0;
			G001 ABCD 0;
			G010 ABCDEFGHIJKLMNOPQGSTUVWXYZ 0;
			G011 ABCD 0;
			B000 ABCDEFGHIJKLMNOPQBSTUVWXYZ 0;
			B001 ABCD 0;
			B010 ABCDEFGHIJKLMNOPQBSTUVWXYZ 0;
			B011 ABCD 0;
			stop;
	}
}

//thinner and faster version for spurts
Class BloodSpray : BD_Blood {
	Default {
		scale 0.12;
		gravity 0.5;
		alpha 0.7;
	}
	override void BD_BloodDecal()
		{
		if (bcolor == 'blue')
			A_SprayDecal("BloodSprayBlue",32);
		else if (bcolor == 'green')
			A_SprayDecal("BloodSprayGreen",32);
		else if (bcolor == 'red')
			A_SprayDecal("BloodSprayRed",32);
	}
	override void Tick() {
		super.Tick();
		if (isFrozen())
			return;
		A_FadeOut(0.05);
	}
}

//long "arterial" spurts
Class BloodSpurt : BD_BloodBase {
	double bpitch;
	double pitchchange;
	double bspeed;
	string sprayactor;
	Default {
		+NOGRAVITY
		+NOINTERACTION
		radius 1;
		height 1;
	}
	override void PostBeginPlay() {
		if (waterlevel > 0) {
			destroy();
			return;
		}
		super.PostBeginPlay();
		bpitch = frandom(1.0,5.0);
		bspeed = frandom(4.0,6.0);
		pitchchange = 0.5;
		sprayactor = "BloodSpray";
	}
	states {
		Spawn:
			TNT1 A 0 NoDelay A_FaceTarget(0,270,0,0);
			TNT1 A 0 A_Jump(256,random(1,5));
			TNT1 AAAAAAAAA 1 { 
				A_SpawnItemEx(sprayactor,0,0,0,	bspeed+frandom(0.0,1.2),0,bpitch,	random(175,185), SXF_TRANSFERPOINTERS);
				bpitch+=pitchchange;
			}
			stop;
	}
}

Class NeckSpurt : BloodSpurt {
	override void PostBeginPlay() {
		super.PostBeginPlay();
		bpitch = frandom(2.0,5.5);
		bspeed = frandom(1.0,2.5);
		sprayactor = "NeckSpray";
		pitchchange = 0.0;
	}
}

Class FrontalSpurt : BloodSpurt {
	override void PostBeginPlay() {
		super.PostBeginPlay();
		bpitch = frandom(0.3,1.2);
		bspeed = frandom(3.0,4.5);
		sprayactor = "NeckSpray";
		pitchchange = 0.0;
	}
}

//shorter and smaller version of bloodspurt
Class NeckSpray : SmallDebris {
	Default {
		smalldebris.dgravity 0.5;
		scale 0.12;
		alpha 0.7;
	}
	static const string bsprite[] =	{ "YBL7","YBL8","YBL9" };
	states {
		spawn:
			TNT1 A 0 NoDelay {
				A_SetScale(scale.x*randompick(-1,1),scale.y*randompick(-1,1));
				roll = random(0,359);
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
			}
			#### ABCDEFGHIJKLMNOPQRS 2 {
				A_FadeOut(0.07);
				return ResolveState(null);
			}
			stop;
	}
}


//large quickly disappearing spray creating a "bloody mist" upon xdeath
Class BFountainSpray : BD_Blood {
	Default {
		-MISSILE
		+NOINTERACTION
		scale 0.45;
		renderstyle "Translucent";
		alpha 0.6;
	}
	states {
		BloodDo:
			#### ABCDEFGHIJKKLLMMNNOOOPPPQQQRRRSSS 1 {
				if (waterlevel > 0) {
					destroy();
					return ResolveState(null);
				}
				vel.z = clamp(vel.z - 0.3,-1.5,10.0);
				a_Setscale(clamp(scale.x * 1.02,0.0,1.5),clamp(scale.y * 1.02,0.0,1.5));
				a_fadeout(0.015);
				return ResolveState(null);
			}
			wait;
	}
}