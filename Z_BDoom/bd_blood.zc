Class BloodGeneral : DebrisGeneral abstract {
	protected name bcolor;
	static const name bsprite[] = { "YBL7","YBL8","YBL9" };
	Default {
		DebrisGeneral.sfxtype "blood";
		+PUFFGETSOWNER
		-NOGRAVITY
		+ROLLSPRITE
		+DONTSPLASH
		gravity 0.7;
		renderstyle "Translucent";
		seesound "none";
		Deathsound "none";
		decal "none";
		height 1;
	}
	states	{
		LoadSprites:
			2PLT ABCDEFGHIJKLMNOPQ 0;
			YBL7 ABCDEFGHIJKLMNOPQRS 0;
			YBL8 ABCDEFGHIJKLMNOPQRS 0;
			YBL9 ABCDEFGHIJKLMNOPQRS 0;
			stop;
		Fade:
			#### # 1 A_FadeOut(0.02);
			loop;
	}
}


Class BD_Blood : BloodGeneral replaces Blood {
	double restscale;
	Default {
		scale 0.35;
		gravity 0.5;
		renderstyle "Translucent";
		alpha 0.8;
		height 8;
		deathsound "none";
	}
	/* 
	I'm only doing the crap below because we don't have direct control over decals, so while I can translate the blood particles created by enemies, 
	I can't translate the decals created by said blood particles (only the decals automatically created behind monsters are translated). Hence the ugly math.
	I could just use BloodTranslation directly for all cases, but that makes the sprite have only one color which diminishes the details 
	(if blood is red, for example, it doesn't mean that the whole image is red, it'll have black and white parts as well). Hence I use manual translation 
	for blue and green and then BloodTranslation for any other color (if it's used).
	 */
	override void PostBeginPlay() {
		if (!bdoom_blood || !target){
			destroy();
			return;
		}
		if (target && (target is "BDoomMonster")) {
			let trg = BDoomMonster(target);
			if (trg) {
				if (trg.burning){
					destroy();
					return;
				}
				trg.meatlist.push(self);
			}
		}
		if (target && target.bloodcolor) {
			//obvious green prevalence
			if (target.bloodcolor.G > 4*(target.bloodcolor.R  + target.bloodcolor.B)) {
				bcolor = 'green';
				A_SetTranslation("GreenBlood");
			}
			//obvious blue prevalence
			else if (target.bloodcolor.B > 4*(target.bloodcolor.R  + target.bloodcolor.G)) {
				bcolor = 'blue';
				A_SetTranslation("BlueBlood");
			}
			//obvious red prevalence. bloodcolor = 0 means default bloodcolor (68 00 00 or specified in MAPINFO). If changed in MAPINFO, it'll be a mismatch, but whaddaya do
			else if (target.bloodcolor.R > 4*(target.bloodcolor.B  + target.bloodcolor.G) || target.bloodcolor == 0) {
				bcolor = 'red';
			}
			//if played with another wad that contains very peculiar blood, like yellow or purple, translate sprites along with it. They won't spawn decals themselves.
			else
				Translation = target.BloodTranslation;
		}
		restscale = frandom(0.1,0.18);
		Super.PostBeginPlay();
	}

	virtual void BD_BloodDecal() {
		if (bcolor == 'blue')
			A_SprayDecal("BloodSplatBlue",32);
		else if (bcolor == 'green')
			A_SprayDecal("BloodSplatGreen",32);
		else if (bcolor == 'red')
			A_SprayDecal("BloodSplatRed",32);
		//no way to transfer shade to decals, so blood of colors other than red/blue/green won't produce decals (they'll still be produced by monsters directly, of course)
	}
	states {
		spawn:
			TNT1 AAA 0; //override hardcoded frame-skipping behavior for Blood
			TNT1 A 0 {
				A_FaceTarget(0,270,180,0);
				A_SetScale(scale.x*randompick(-1,1)*frandom(0.7,1.2),scale.y*randompick(-1,1)*frandom(0.7,1.2));
				roll = random(0,359);
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
				return resolvestate("BloodDo");
			}
		BloodDo:
			#### ABCDEFGHIJKLMNOPQRS 1 {
				if (waterlevel > 0)
					return ResolveState("Water");
				return ResolveState(null);
			}
			stop;
		Death:
			TNT1 A 0 { 
				A_Stop();
				BD_BloodDecal();
				A_Scream();
				A_SetScale(restscale*randompick(1,-1),restscale*randompick(1,-1));
				if (pos.z >= ceilingz-10){	//Spawn ceiling blood if it reaches the ceiling. I use ceiling-10 so that it happens more often; blood doesn't ACTUALLY often hit the ceiling
					let a = CeilingSplat(Spawn("CeilingSplat",(pos.x,pos.y,ceilingz)));
					if (a) {
						a.translation = translation;
						a.A_SetRenderStyle(alpha,GetRenderStyle());
						a.scale = scale;
						if (target && (target is "BDoomMonster"))	{
							a.target = target;
							let m = BDoomMonster(target);
							if (m) m.meatlist.Push(a);
						}
					}
					destroy();
					return ResolveState(null);
				}	
				
				if (floorpic == skyflatnum || pos.z != floorz || waterlevel > 1) { //if the blood hits wall, or sky, or ends up underwater
					destroy();
					return ResolveState(null);
				}
				if (CheckLandingSize(24))
					scale*=0.5;
				if	(CheckLandingSize(18))
					scale*=0.5;
				if	(CheckLandingSize(12))
					scale*=0.5;
				if	(CheckLandingSize(6)) {
					destroy();
					return ResolveState(null);
				}
				A_SetSize(16*scale.x,5);
				
				//bFLATSPRITE = true;
				bNOINTERACTION = true;
				A_ChangeLinkFlags(blockmap:true);
				bMOVEWITHSECTOR = true;
				bRELATIVETOFLOOR = true;
				A_SetScale(abs(scale.x),abs(scale.y));
				angle = random(0,36);
				A_SetRenderStyle(1,STYLE_Normal);
				return ResolveState(null);
			}
			MODL A 0 { 
				frame = random(0,16);
				if (CheckWater())
					return ResolveState("Water");
				return ResolveState(null);
			}
			/*2PLT A 0 { 
				frame = random(0,16);
				if (CheckWater())
					return ResolveState("Water");
				return ResolveState(null);
			}*/

			#### # -1;
			stop;
		Raise:
			TNT1 A 0 {
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
				roll = random(0,359);
				FlyBack();
			}
			#### SRQPONMLKJIHGFEDCBA 1 bright {
				A_FadeOut(0.03);
				if (target &&  Distance3D(target) < 32) {
					destroy();
					return ResolveState(null);
				}
				return ResolveState(null);
			}
			stop;
		Water:
			#### # 0 A_SetRenderStyle(alpha,STYLE_Translucent);
			#### # 1 {
				A_FadeOut(0.04);
				scale*=1.03;
			}
			wait;
	}
}

//resting version of blood drop without any animation
Class BD_BloodPool : BD_Blood {
	Default {
		+NOINTERACTION
		+FLATSPRITE
		+MOVEWITHSECTOR
		+RELATIVETOFLOOR
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		if (floorpic == skyflatnum || waterlevel > 0 || CheckWater()){
			destroy();
			return;
		}
	}
	states {
		spawn:
			TNT1 A 0 NoDelay {
				A_SetScale(restscale*randompick(1,-1),restscale*randompick(1,-1));
				if (CheckLandingSize(24))
					scale*=0.5;
				if	(CheckLandingSize(18))
					scale*=0.5;
				if	(CheckLandingSize(12))
					scale*=0.5;
				if	(CheckLandingSize(6)){
					destroy();
					return ResolveState(null);
				}
				SetOrigin((pos.x,pos.y,floorz),false);
				//A_SetScale(restscale*randompick(1,-1),restscale*randompick(1,-1));	
				return ResolveState(null);	
			}
			2PLT A 0 { frame = random(0,16); }
			#### # -1; /*10 {
				if (CheckWater())
					return ResolveState("Water");
				return ResolveState(null);
			}
			wait;*/ stop;
	}
}


Class CeilingSplat : BloodGeneral {
	Default {
		-MISSILE
		+NOGRAVITY
		+FLATSPRITE
		+NOINTERACTION
		-RELATIVETOFLOOR
		-MOVEWITHSECTOR
		height 1;
		scale 0.35;
		renderstyle "Translucent";
		alpha 0.8;
	}
	Override Void PostBeginPlay() {
		super.PostBeginPlay();
		if (ceilingpic == skyflatnum) {
			destroy();
			return;
		}
		if (CheckLandingSize(24,true))
			scale*=0.5;
		if (CheckLandingSize(18,true))
			scale*=0.5;
		if (CheckLandingSize(12,true))
			scale*=0.5;
		if (CheckLandingSize(6,true)){
			destroy();
			return;
		}
	}
	states {
		Spawn:
			2PLT A 0 NoDelay {
				frame = random(0,16);
			}
			#### # 5 {
				SetOrigin((pos.x,pos.y,ceilingz-1),true);
				A_SpawnitemEx("CeilingBloodDrop",frandom(-2.0,2.0),frandom(-2.0,2.0),-1.,0,0,0,0,SXF_TRANSFERTRANSLATION|SXF_TRANSFERSTENCILCOL|SXF_TRANSFERRENDERSTYLE|SXF_NOPOINTERS,250);
				A_FadeTo(0.1,0.001,1);
				return ResolveState(null);
			}
			wait;
		Raise:
			#### # 1 { return ResolveState("Fade"); }
			stop;
	}
}

Class CeilingBloodDrop : BloodGeneral {
	Default {
		+FORCEYBILLBOARD
		+NOINTERACTION
		-FLOORCLIP
		scale 0.1;
		alpha 0.75;
	}
	override void PostBeginPlay() {
		super.PostBeginPlay();
		scale*= frandom(0.8,1.1);
		scale.x*=randompick(-1,1);	
	}
	states {
		spawn:
			BLOD UVWWXXYYY 2;
			TNT1 A 0 { vel.z = -3.4; }
			BLOD ZZZZZZZZZZZZZZZZZZZZZZZZZ 1 {
				if (waterlevel > 0) {
					destroy();
					return ResolveState(null);
				}
				if (pos.z <= floorz)
					return ResolveState("Death");
				return ResolveState(null);
			}
			stop;
		Death:
			TNT1 A 0 {
				vel.z = 0.0;
				SetOrigin((pos.x,pos.y,floorz),0);
				scale.x = frandom(0.22,0.25)*randompick(-1,1);
			}
			BLOD GHIJK 3;
			stop;
	}
}


Class AniBloodPool : BloodGeneral {
	bool instant; //if true, the blood pool will instantly go through all the phases and reach the required size â€” for decorative purposes such as Heart Column, where animation is unneeded, but checking for overhang may still important
	double psize;
	private int ver;
	Default {
		+NOINTERACTION
		+RELATIVETOFLOOR
		+MOVEWITHSECTOR
		-MISSILE
		height 1;
		renderstyle 'Normal';
		scale 0.2;
	}
	override void PostBeginPlay() {
		Super.PostBeginPlay();
		if (waterlevel > 0) {
			destroy();
			return;
		}
		double pscale = scale.x*frandom(1.1,1.8);
		psize = pscale*22;
		if (CheckLandingSize (psize) || waterlevel > 0) {
			destroy();
			return;
		}
		angle = random(0,359);

		if (target && target.bloodcolor) {
			if (target.bloodcolor.G > 4*(target.bloodcolor.R  + target.bloodcolor.B))
				bcolor = 'green';
			else if (target.bloodcolor.B > 4*(target.bloodcolor.R  + target.bloodcolor.G))
				bcolor = 'blue';
			else if (target.bloodcolor.R > 4*(target.bloodcolor.B  + target.bloodcolor.G) || target.bloodcolor == 0)
				bcolor = 'red';
			else
				Translation = target.BloodTranslation;
		}		
	}	
	override void Tick () {
		super.Tick();
		if (isFrozen())
			return;
		if (CheckWater()) {
			A_SetRenderstyle(alpha,STYLE_Translucent);
			A_FadeOut(0.01);
		}
	}
	states	{
		Spawn:
			TNT1 A 0 NoDelay {
				SetOrigin((pos.x,pos.y,floorz+0.5),0);
				ver = randompick(0,1);
				if (ver == 0) {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G000");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B000");
					else
						sprite = GetSpriteIndex("R000");
				}
				else {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G010");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B010");
					else
						sprite = GetSpriteIndex("R010");
				}
			}
			#### ABCDEFGHI 2 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=2.0;
				return ResolveState(null);
			}
			#### JKLMNOPQRSTU 2 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.2;
				return ResolveState(null);
			}
			#### VWXYZ 3 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.0;
				return ResolveState(null);
			}
			//running out of alphabet letters
			TNT1 A 0 {
				if (ver == 0) {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G001");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B001");
					else
						sprite = GetSpriteIndex("R001");
				}
				else {
					if (bcolor == 'green')
						sprite = GetSpriteIndex("G011");
					else if (bcolor == 'blue')
						sprite = GetSpriteIndex("B011");
					else
						sprite = GetSpriteIndex("R011");
				}
			}
			#### ABCD 3 {
				if (instant)
					A_SetTics(0);
				if (CheckLandingSize (psize))
					return ResolveState("Rest");
				psize+=1.0;
				return ResolveState(null);
			}
			goto rest;
		Rest:
			#### # -1;
			stop;
		Raise:
			#### # 0 {
				A_SetRenderstyle(alpha,STYLE_Translucent);
				//console.printf("fade blood pool");
			}
			#### # 1 {
				scale*=0.92;
				A_FadeOut(0.03);
			}
			wait;
		LoadSprites:
			R000 ABCDEFGHIJKLMNOPQRSTUVWXYZ 0;
			R001 ABCD 0;
			R010 ABCDEFGHIJKLMNOPQRSTUVWXYZ 0;
			R011 ABCD 0;
			G000 ABCDEFGHIJKLMNOPQGSTUVWXYZ 0;
			G001 ABCD 0;
			G010 ABCDEFGHIJKLMNOPQGSTUVWXYZ 0;
			G011 ABCD 0;
			B000 ABCDEFGHIJKLMNOPQBSTUVWXYZ 0;
			B001 ABCD 0;
			B010 ABCDEFGHIJKLMNOPQBSTUVWXYZ 0;
			B011 ABCD 0;
			stop;
	}
}

//for projectile bullets
Class BD_BloodSplatter : BD_Blood replaces BloodSplatter {}

//thinner and faster version for spurts
Class BloodSpray : BD_Blood {
	Default {
		scale 0.12;
		gravity 0.5;
		alpha 0.7;
	}
	override void BD_BloodDecal()
		{
		if (bcolor == 'blue')
			A_SprayDecal("BloodSprayBlue",32);
		else if (bcolor == 'green')
			A_SprayDecal("BloodSprayGreen",32);
		else if (bcolor == 'red')
			A_SprayDecal("BloodSprayRed",32);
	}
	override void Tick() {
		super.Tick();
		if (isFrozen())
			return;
		A_FadeOut(0.05);
	}
}

//long "arterial" spurts
Class BloodSpurt : BloodGeneral {
	double bpitch;
	double pitchchange;
	double bspeed;
	string sprayactor;
	Default {
		+NOGRAVITY
		+NOINTERACTION
		radius 1;
		height 1;
	}
	override void PostBeginPlay() {
		if (waterlevel > 0) {
			destroy();
			return;
		}
		super.PostBeginPlay();
		bpitch = frandom(1.0,5.0);
		bspeed = frandom(4.0,6.0);
		pitchchange = 0.5;
		sprayactor = "BloodSpray";
	}
	states {
		Spawn:
			TNT1 A 0 NoDelay A_FaceTarget(0,270,0,0);
			TNT1 A 0 A_Jump(256,random(1,5));
			TNT1 AAAAAAAAA 1 { 
				A_SpawnItemEx(sprayactor,0,0,0,	bspeed+frandom(0.0,1.2),0,bpitch,	random(175,185), SXF_TRANSFERPOINTERS);
				bpitch+=pitchchange;
			}
			stop;
	}
}

Class NeckSpurt : BloodSpurt {
	override void PostBeginPlay() {
		super.PostBeginPlay();
		bpitch = frandom(2.0,5.5);
		bspeed = frandom(1.0,2.5);
		sprayactor = "NeckSpray";
		pitchchange = 0.0;
	}
}

Class FrontalSpurt : BloodSpurt {
	override void PostBeginPlay() {
		super.PostBeginPlay();
		bpitch = frandom(0.3,1.2);
		bspeed = frandom(3.0,4.5);
		sprayactor = "NeckSpray";
		pitchchange = 0.0;
	}
}

//shorter and smaller version of bloodspurt
Class NeckSpray : SmallDebris {
	Default {
		smalldebris.dgravity 0.5;
		scale 0.12;
		alpha 0.7;
	}
	static const string bsprite[] =	{ "YBL7","YBL8","YBL9" };
	states {
		spawn:
			TNT1 A 0 NoDelay {
				A_SetScale(scale.x*randompick(-1,1),scale.y*randompick(-1,1));
				roll = random(0,359);
				sprite = GetSpriteIndex(bsprite[random(0,2)]);
			}
			#### ABCDEFGHIJKLMNOPQRS 2 {
				A_FadeOut(0.07);
				return ResolveState(null);
			}
			stop;
	}
}


//large quickly disappearing spray creating a "bloody mist" upon xdeath
Class BFountainSpray : BD_Blood {
	Default {
		-MISSILE
		+NOINTERACTION
		scale 0.45;
		renderstyle "Translucent";
		alpha 0.6;
	}
	states {
		BloodDo:
			#### ABCDEFGHIJKKLLMMNNOOOPPPQQQRRRSSS 1 {
				if (waterlevel > 0) {
					destroy();
					return ResolveState(null);
				}
				vel.z = clamp(vel.z - 0.3,-1.5,10.0);
				a_Setscale(clamp(scale.x * 1.02,0.0,1.5),clamp(scale.y * 1.02,0.0,1.5));
				a_fadeout(0.015);
				return ResolveState(null);
			}
			wait;
	}
}